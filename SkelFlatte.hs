-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelFlatte where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsFlatte

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: AbsFlatte.Ident -> Result
transIdent x = case x of
  AbsFlatte.Ident string -> failure x

transProgram :: Show a => AbsFlatte.Program' a -> Result
transProgram x = case x of
  AbsFlatte.ProgramDef _ dec -> failure x

transDec :: Show a => AbsFlatte.Dec' a -> Result
transDec x = case x of
  AbsFlatte.FDec _ type_ ident args block -> failure x
  AbsFlatte.VDec _ type_ ident -> failure x
  AbsFlatte.VdecInit _ type_ ident expr -> failure x

transArg :: Show a => AbsFlatte.Arg' a -> Result
transArg x = case x of
  AbsFlatte.ValArg _ ident type_ -> failure x
  AbsFlatte.RefArg _ ident type_ -> failure x

transBlock :: Show a => AbsFlatte.Block' a -> Result
transBlock x = case x of
  AbsFlatte.Block _ stmts -> failure x

transStmt :: Show a => AbsFlatte.Stmt' a -> Result
transStmt x = case x of
  AbsFlatte.DecStmt _ dec -> failure x
  AbsFlatte.Assign _ ident expr -> failure x
  AbsFlatte.Incr _ ident -> failure x
  AbsFlatte.Decr _ ident -> failure x
  AbsFlatte.Ret _ expr -> failure x
  AbsFlatte.If _ expr block -> failure x
  AbsFlatte.IfElse _ expr block1 block2 -> failure x
  AbsFlatte.While _ expr block -> failure x
  AbsFlatte.Break _ -> failure x
  AbsFlatte.Cont _ -> failure x
  AbsFlatte.SExp _ expr -> failure x

transType :: Show a => AbsFlatte.Type' a -> Result
transType x = case x of
  AbsFlatte.Int _ -> failure x
  AbsFlatte.Str _ -> failure x
  AbsFlatte.Bool _ -> failure x
  AbsFlatte.TypTuple _ types -> failure x

transExpr :: Show a => AbsFlatte.Expr' a -> Result
transExpr x = case x of
  AbsFlatte.EVar _ ident -> failure x
  AbsFlatte.ELitInt _ integer -> failure x
  AbsFlatte.ELitStr _ string -> failure x
  AbsFlatte.ETup _ tuple -> failure x
  AbsFlatte.ETupTak _ expr integer -> failure x
  AbsFlatte.ELitTrue _ -> failure x
  AbsFlatte.ElitFalse _ -> failure x
  AbsFlatte.ElitMaybe _ -> failure x
  AbsFlatte.ERunFun _ ident exprs -> failure x
  AbsFlatte.EMinus _ expr -> failure x
  AbsFlatte.ENot _ expr -> failure x
  AbsFlatte.EMul _ expr1 mulop expr2 -> failure x
  AbsFlatte.EAdd _ expr1 addop expr2 -> failure x
  AbsFlatte.EComp _ expr1 compop expr2 -> failure x
  AbsFlatte.EAnd _ expr1 expr2 -> failure x
  AbsFlatte.EOr _ expr1 expr2 -> failure x

transTuple :: Show a => AbsFlatte.Tuple' a -> Result
transTuple x = case x of
  AbsFlatte.Tuple _ exprs -> failure x

transAddOp :: Show a => AbsFlatte.AddOp' a -> Result
transAddOp x = case x of
  AbsFlatte.Plus _ -> failure x
  AbsFlatte.Minus _ -> failure x

transMulOp :: Show a => AbsFlatte.MulOp' a -> Result
transMulOp x = case x of
  AbsFlatte.Times _ -> failure x
  AbsFlatte.Div _ -> failure x
  AbsFlatte.Mod _ -> failure x

transCompOp :: Show a => AbsFlatte.CompOp' a -> Result
transCompOp x = case x of
  AbsFlatte.LTH _ -> failure x
  AbsFlatte.LE _ -> failure x
  AbsFlatte.GTH _ -> failure x
  AbsFlatte.GE _ -> failure x
  AbsFlatte.EQU _ -> failure x
  AbsFlatte.NE _ -> failure x
